// Generated by CoffeeScript 1.7.1
(function() {
  var distance, isArray, isEmpty, isString, _ref;

  _ref = require('./utils'), isArray = _ref.isArray, isString = _ref.isString, isEmpty = _ref.isEmpty;


  /*
  Compute the distance between two strings
  
  TODO
    This function needs a bit more research.
  
    Ideally, I would like a function that give me:
    - 1 for exact match between two strings
    - tend to 0 the further I get from the target string.
  
  However, there are various approach and metrics to this, it is really hard to pick one.
  
  Basically:
   - character substitution (typos)
   - phonetic(similarly sounding words)
   - n-grams (sentences)
  
  See:
   - http://www.postgresql.org/docs/9.2/static/fuzzystrmatch.html
   - http://www.postgresql.org/docs/9.2/static/pgtrgm.html
   - http://www.mi.fu-berlin.de/wiki/pub/ABI/AdvancedAlgorithms11_Searching/script-05-FastFilteringQuasar.pdf
   - http://en.wikipedia.org/wiki/N-gram
   - http://stackoverflow.com/questions/1938678/q-gram-approximate-matching-optimisations
  
  For for now, I am experimenting. Maybe I will use a couple of functions.
   */

  exports.distance = distance = function(str1, str2, n) {
    var depth, final_weight, max, max1, max2, nb_feats, ngram1, ngram2, ngrams1, ngrams2, weight, _i, _j, _len, _len1, _ngramize, _ref1, _ref2;
    if (n == null) {
      n = 3;
    }
    console.log("distance(" + str1 + ", " + str2 + ")");
    _ngramize = function(str, n) {
      var i, len, maxScore, r, words, _i, _j, _ref1;
      str = str.trim();
      str = str.replace(/,/, ' ', 'g');
      str = str.replace(/\s+/, ' ', 'g');
      str = str.split(' ');
      r = [];
      maxScore = 0;
      for (len = _i = 1; 1 <= n ? _i <= n : _i >= n; len = 1 <= n ? ++_i : --_i) {
        for (i = _j = 0, _ref1 = str.length; _j < _ref1; i = _j += 1) {
          words = str.slice(i, i + len);
          if (words.length < len) {
            continue;
          }
          r.push(words.join(','));
          maxScore += Math.pow(10, len);
        }
      }
      return [r, maxScore];
    };
    _ref1 = _ngramize(str1, n), ngrams1 = _ref1[0], max1 = _ref1[1];
    _ref2 = _ngramize(str2, n), ngrams2 = _ref2[0], max2 = _ref2[1];
    max = Math.max(max1, max2);
    weight = 0;
    nb_feats = 0;
    for (_i = 0, _len = ngrams1.length; _i < _len; _i++) {
      ngram1 = ngrams1[_i];
      for (_j = 0, _len1 = ngrams2.length; _j < _len1; _j++) {
        ngram2 = ngrams2[_j];
        if (ngram1 === ngram2) {
          depth = ngram1.split(',').length;
          if (depth > nb_feats) {
            nb_feats = depth;
          }
          if (depth > 0) {
            weight += Math.pow(10, depth);
          }
          console.log("depth: " + depth);
        }
      }
    }
    console.log("weight: " + weight + ", max: " + max + ", nb_feats: " + nb_feats);
    console.log("result: " + (weight / max));
    final_weight = max === 0 ? 1 : weight / max;
    return [final_weight, nb_feats];
  };


  /*
  Clean a string from punctiation and useless stuff.
  
  TODO Document it clearly: what it does and when to use it.
   */

  exports.cleanContent = function(content) {
    content = content.replace(/(&[a-zA-Z]+;|\\t)/g, ' ');
    content = content.replace(/(?:\.|\?|!|\:|;|,)+/g, '.');
    content = content.replace(/\s+/g, ' ');
    content = content.replace(/(?:\\n)+/g, '');
    content = content.replace(/\n+/g, '');
    return content;
  };

}).call(this);
