// Generated by CoffeeScript 1.7.1
(function() {
  var Fussy, bench, debug, extract, fs, path, text, utils,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  path = require('path');

  utils = require('./utils');

  text = require('./text');

  bench = require('./bench');

  extract = require('./extract');

  debug = function(msg) {
    return console.log(msg);
  };


  /*
  The main Fussy class
  
  TODO add more comments and documentation
   */

  Fussy = (function() {
    function Fussy(objects) {
      this.objects = objects != null ? objects : [];
      this.toolbox = {
        parseOne: utils.parseOne,
        parseMany: utils.parseMany,
        randomizeCSV: utils.randomizeCSV,
        loadCSV: utils.loadCSV,
        pperf: utils.pperf,
        pstats: utils.pstats,
        dataset: utils.dataset,
        shuffle: utils.shuffle,
        bench: bench
      };
    }


    /*
    TODO: take a param in account?
     */

    Fussy.prototype.repair = function(objects) {
      var key, obj, query, repaired, results, schema, value, _i, _len;
      if (objects == null) {
        objects = this.objects;
      }
      schema = {};
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        for (key in obj) {
          value = obj[key];
          schema[key] = true;
        }
      }
      results = (function() {
        var _j, _len1, _ref, _results;
        _results = [];
        for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
          obj = objects[_j];
          query = {
            objects: objects,
            select: [],
            where: {}
          };
          for (key in schema) {
            value = schema[key];
            if (key in obj) {
              query.where[key] = obj[key];
            } else {
              query.select.push(key);
            }
          }
          repaired = {};
          for (key in obj) {
            value = obj[key];
            repaired[key] = value;
          }
          _ref = this.query(query).best();
          for (key in _ref) {
            value = _ref[key];
            repaired[key] = value;
          }
          _results.push(repaired);
        }
        return _results;
      }).call(this);
      return results;
    };


    /*
    Load an object into the memory
     */

    Fussy.prototype.insert = function(data) {
      var obj, _i, _len;
      if (utils.isArray(data)) {
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          obj = data[_i];
          this.objects.push(obj);
        }
      } else if (utils.isString(data)) {
        this.insert(utils.loadJSON(data));
      } else {
        this.objects.push(data);
      }
      return this;
    };


    /*
    This helper should probably be deleted
     */

    Fussy.prototype["import"] = function(file, schema) {
      return this.insert(utils.parseMany(schema, utils.loadCSV(file)));
    };


    /*
    Executes a query
    
    TODO clean this function, it is too complicated (callback hell)
     */

    Fussy.prototype.query = function(query) {
      var all, best, mix, sort, _executeJob;
      _executeJob = (function(_this) {
        return function() {
          var MAGIC, complexity, delta, depth, factors, features, key, match, nb_feats, obj, result, tmp, type, types, value, weight, where, whereValue, whereValues, _depth, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _nb_feats, _ref, _ref1, _ref2, _ref3, _ref4;
          result = {};
          types = {};
          if (utils.isString(query.select)) {
            tmp = {};
            tmp[query.select] = [];
            query.select = tmp;
          }
          if (!utils.isArray(query.where)) {
            query.where = [query.where];
          }
          if (query.objects == null) {
            query.objects = _this.objects;
          }
          _ref = query.objects;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            obj = _ref[_i];
            features = extract(obj);
            weight = 0;
            factors = [];
            nb_feats = 0;
            MAGIC = 2;
            _ref1 = query.where;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              where = _ref1[_j];
              depth = 0;
              complexity = 0;
              for (_k = 0, _len2 = features.length; _k < _len2; _k++) {
                _ref2 = features[_k], type = _ref2[0], key = _ref2[1], value = _ref2[2];
                if (key in where) {
                  whereValues = utils.isArray(where[key]) ? where[key] : [where[key]];
                  match = false;
                  for (_l = 0, _len3 = whereValues.length; _l < _len3; _l++) {
                    whereValue = whereValues[_l];
                    switch (type) {
                      case 'String':
                        value = "" + value;
                        whereValue = "" + whereValue;
                        if (__indexOf.call(value, ' ') >= 0 || __indexOf.call(whereValue, ' ') >= 0) {
                          _ref3 = text.distance(value, whereValue), _depth = _ref3[0], _nb_feats = _ref3[1];
                          depth += _depth;
                          nb_feats += _nb_feats;
                          match = true;
                        } else {
                          if (value === whereValue) {
                            depth += 1;
                            match = true;
                          }
                        }
                        break;
                      case 'Number':
                        whereValue = Number(whereValue);
                        if (!isNaN(whereValue) && isFinite(whereValue)) {
                          delta = Math.abs(value - whereValue);
                          depth += 1 / (1 + delta);
                          match = true;
                        }
                        break;
                      case 'Boolean':
                        if ((Boolean(value)) === (Boolean(whereValue))) {
                          depth += 1;
                          match = true;
                        }
                        break;
                      default:
                        console.log("type " + type + " not supported");
                    }
                  }
                  if (match) {
                    nb_feats += 1;
                  }
                }
              }
              depth *= Math.min(6, 300 / nb_feats);
              weight += Math.pow(10, Math.min(300, depth));
            }
            for (_m = 0, _len4 = features.length; _m < _len4; _m++) {
              _ref4 = features[_m], type = _ref4[0], key = _ref4[1], value = _ref4[2];
              if (!(key in query.select)) {
                continue;
              }
              if (!(key in types)) {
                types[key] = type;
              }
              if (!(key in result)) {
                result[key] = {};
              }
              if (!(value in result[key])) {
                result[key][value] = 0;
              }
              match = false;
              if (utils.isArray(query.select[key])) {
                if (query.select[key].length) {
                  if (__indexOf.call(query.select[key], value) >= 0) {
                    match = true;
                  }
                } else {
                  match = true;
                }
              } else {
                if (value === query.select[key]) {
                  match = true;
                }
              }
              if (match) {
                result[key][value] += weight;
              }
            }
          }
          return {
            options: result,
            types: types
          };
        };
      })(this);
      sort = (function(_this) {
        return function(fn, cb) {
          var key, option, options, result, types, weight, _ref;
          result = {};
          _ref = _executeJob(), options = _ref.options, types = _ref.types;
          for (key in options) {
            options = options[key];
            result[key] = [];
            for (option in options) {
              weight = options[option];
              if (types[key] === 'Number') {
                option = Number(option);
              } else if (types[key] === 'Boolean') {
                option = Boolean(option);
              }
              result[key].push([option, weight]);
            }
            result[key].sort(fn);
          }
          if (cb != null) {
            cb(result);
            return void 0;
          } else {
            return result;
          }
        };
      })(this);
      all = (function(_this) {
        return function(cb) {
          var fn;
          fn = function(a, b) {
            return b[1] - a[1];
          };
          return sort(fn, cb);
        };
      })(this);
      best = (function(_this) {
        return function() {
          var key, options, result, _ref;
          result = {};
          _ref = all();
          for (key in _ref) {
            options = _ref[key];
            result[key] = options[0][0];
          }
          if (typeof cb !== "undefined" && cb !== null) {
            cb(result);
            return void 0;
          } else {
            return result;
          }
        };
      })(this);
      ({
        toString: (function(_this) {
          return function() {
            return utils.pretty(all());
          };
        })(this)
      });
      mix = (function(_this) {
        return function() {
          var isNumerical, key, option, options, result, sum, types, weight, _ref;
          result = {};
          _ref = _executeJob(), options = _ref.options, types = _ref.types;
          for (key in options) {
            options = options[key];
            isNumerical = types[key] === 'Number';
            if (utils.isNumerical) {
              sum = 0;
              for (option in options) {
                weight = options[option];
                sum += weight;
              }
              result[key] = 0;
              for (option in options) {
                weight = options[option];
                option = Number(option);
                result[key] += option * (weight / sum);
              }
            } else {
              result[key] = [];
              for (option in options) {
                weight = options[option];
                if (types[key] === 'Boolean') {
                  option = Boolean(option);
                }
                result[key].push([option, weight]);
              }
              result[key].sort(function(a, b) {
                return b[1] - a[1];
              });
              best = result[key][0];
              result[key] = best[0];
            }
          }
          if (typeof cb !== "undefined" && cb !== null) {
            cb(result);
            return void 0;
          } else {
            return result;
          }
        };
      })(this);
      return {
        sort: sort,
        all: all,
        best: best,
        mix: mix,
        toString: toString
      };
    };

    return Fussy;

  })();

  module.exports = Fussy;

}).call(this);
