{"name":"Fussy","tagline":"JSON prediction and recommendation engine","body":"# node-fussy\r\n\r\n*JSON prediction and recommendation engine*\r\n\r\n[![Build Status](https://secure.travis-ci.org/jbilcke/node-fussy.png)](http://travis-ci.org/jbilcke/node-fussy)\r\n[![Dependency Status](https://gemnasium.com/jbilcke/node-fussy.png)](https://gemnasium.com/jbilcke/node-fussy)\r\n\r\n## Summary\r\n\r\nFussy is an inference engine for Node. You can use it to guess missing values in a JSON object.\r\n\r\nIt tried to find the most probable values for missing attributes by scanning a database of previously seen objects, computing a weighted average based on similarity.\r\n\r\n\r\n## Examples\r\n\r\nDemo examples (included in the project):\r\n\r\n- [Logic: playing with boolean and fuzzy truth tables](https://github.com/jbilcke/node-fussy/tree/master/examples/logic)\r\n- [Mushrooms: recommendation of mushrooms](https://github.com/jbilcke/node-fussy/tree/master/examples/mushrooms)\r\n\r\nMore examples:\r\n\r\n- [Sonar: categorization of sonar data into mines or rocks](https://github.com/jbilcke/node-fussy-examples/tree/master/sonar)\r\n- [Wilt: detecting diseased trees in Quickbird imagery](https://github.com/jbilcke/node-fussy-examples/tree/master/wilt)\r\n- [Emotiv: detecting eye state from Emotiv EEG Headset](https://github.com/jbilcke/node-fussy-examples/tree/master/emotiv)\r\n- [Letters: letter recognition (OCR)](https://github.com/jbilcke/node-fussy-examples/tree/master/letters)\r\n\r\n\r\n## License\r\n\r\nBSD (see LICENCE.txt file).\r\n\r\n## Current issues\r\n\r\nFussy is an experimental project, and has a number of pitfalls:\r\n\r\n - no tests yet (but soon)\r\n - code is alpha quality, not reviewed\r\n - all data must be loaded into memory (cannot use a remote db yet)\r\n - extremely slow (see mushroom demo..)\r\n - the \"0\" value is not supported well\r\n - not tested for strings (distance function is a bit broken, and will be rewritten)\r\n - and probably many other bugs..\r\n\r\n\r\n## How it works\r\n\r\n### Algorithm\r\n\r\nThe algorithm works as the following:\r\n\r\nFor a given JSON object with some missing fields, it tries to determine the most probable value of these fields, by looking at all the past values, and computing the average.\r\n\r\nHowever, it does a weighted average: a different \"trust\" is given to each past object, depending on how close and relevant they are from the object to repair.\r\n\r\nFor this, what Fussy do is iteraring over all the stored objects (in a map-reduce fashion), and computing a distance score, based on the similarity between values: strings, numbers..\r\n\r\nThis distance will be used to weight the value of the missing field when computing the average.\r\n\r\n\r\n\r\n## Quick-start\r\n\r\n### Installation\r\n\r\n#### As a dependency\r\n\r\nGo to your Node (and NPM-managed) project, and run:\r\n\r\n    $ npm install fussy --save\r\n\r\n#### From sources\r\n\r\nTo download the sources, build the coffee-script and link into your system:\r\n\r\n    $ git clone git@github.com:jbilcke/node-fussy.git\r\n    $ cd node-fussy\r\n    $ npm run build\r\n    $ npm link\r\n\r\n\r\n### Initialization\r\n\r\nFirst you have to get an instance of the class Fussy\r\n\r\n```javascript\r\nvar Fussy = require('fussy');\r\nvar fussy = new Fussy();\r\n```\r\n\r\n### Inserting JSON data\r\n\r\nThen you can insert documents. You have a few ways of doing this.\r\n\r\nYou can use use the `insert` method, which takes a JSON object, or an array of\r\nobjects:\r\n\r\n```javascript\r\nfussy\r\n  .insert({ 'food': 'rice',  'taste': 'good'});\r\n  .insert([\r\n    { 'food': 'salad', 'taste': 'good'},\r\n    { 'food': 'grass', 'taste': 'bad' }\r\n  ]);\r\n\r\n```\r\n\r\n### Importing a dataset\r\n\r\nAfter spending some time using Fussy on various datasets, I found it handy\r\nto write a small importer for CSV files. So here we go!\r\n\r\nThe `import` function takes an input CSV file, and a list of columns as parameter:\r\n\r\n```javascript\r\nvar data = fussy.import('thermal.csv', [ 'day', 'temperature' ]);\r\n```\r\n\r\nThis second parameter can be used to define types:\r\n\r\n```javascript\r\nfussy.import('thermal.csv', [\r\n    ['day','String'],\r\n    ['temperature','Number']\r\n]);\r\n```\r\n\r\nYou can also define a dictionary of values, when using Strings:\r\n\r\n```javascript\r\nfussy.import('thermal.csv', [\r\n    ['day', {\r\n      'mon': 'Monday',\r\n      'tue': 'Tuesday',\r\n      'wed': 'Wednesday',\r\n      'thu': 'Thursday',\r\n      'fri': 'Friday',\r\n      'sat': 'Saturday',\r\n      'sun': 'Sunday'\r\n      }],\r\n    ['temperature','Number']\r\n]);\r\n```\r\n\r\n### Using the dataset function\r\n\r\nSometimes you need to do some operations on a dataset before using it.\r\n\r\nFor instance, maybe you only want to keep a subset of the dataset, or do\r\nrandom sampling, so you need access to the array before importing it.\r\n\r\nFussy provides a function to create a dataset (array of JSONs), available\r\nin the `fussy.toolbox` object.\r\n\r\nThe `fussy.toolbox.dataset` takes an input CSV file and a list of columns as\r\nparameter.\r\n\r\nIt works like the import function:\r\n\r\n```javascript\r\nvar data = fussy.toolbox.dataset('thermal.csv', [ 'day', 'temperature' ]);\r\n```\r\n\r\nYou can then manipulate this array, before importing it. For instance:\r\n\r\n```javascript\r\nvar data = fussy.toolbox.shuffle(\r\n  fussy.toolbox.dataset('data.csv', 'schema.json')\r\n);\r\n```\r\n\r\nWill load the dataset and shuffle it.\r\n\r\n\r\n### Predicting data\r\n\r\n\r\n```javascript\r\nvar query = fussy.query({\r\n  select: ['column'],\r\n  where: {\r\n    foo: '',\r\n    bar: ''\r\n  }\r\n});\r\n```\r\n\r\n### Using the results\r\n\r\nWhen you call the query object, what you get is a result set, or \"view\" on\r\nthe data. This view has the following methods:\r\n\r\n#### best()\r\n\r\nThe `best` function returns the best value for a given field. It actually\r\njust takes the first element of the `all` function.\r\n\r\nDepending on the distribution and the category of problem you are trying to\r\nsolve, this might not be the best choice for you.\r\n\r\n#### mix()\r\n\r\nThe `mix` compute the weighted average value for a numeric field.\r\n\r\nFor instance, say there are 3 possible values for a \"temperature\" field: 10, 20, 40..\r\n\r\nWhile the `all` function will returns an array of value->weight, the `mix`\r\nfunction will directly returns you the weighted average, eg. 23.33.\r\n\r\n#### all()\r\n\r\nThe `all` function returns the distribution of values: an array sorted by weight,\r\nof all possible choices for the requested fields.\r\n\r\nThis is actually an array of `(value, weight)` tuples.\r\n\r\nUse this function if you want access to raw data, and need to make\r\nmultiple, weighted decisions. (eg. for investment, risk management use cases).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}